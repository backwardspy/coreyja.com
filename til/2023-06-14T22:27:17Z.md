---
title: Ruby and Sorbet Module Loading Order
date: 2023-06-14
slug: sorbet-module-loading
---

Today I learned that Sorbet interfaces do some magic to override how Ruby
module and method overloading usually works.

We had a base class lets call it `SomeBaseClass` and it implemented a method like `api_options`.
So we had the following and `OurClass#api_options` was working as expected.

```ruby
class OurClass < SomeBaseClass
  include ApiInterface
end
```

But what was interesting is `ApiInterface` was defined to need a
`api_options` method, which looks like this

```ruby
sig { abstract.params(foo: String).return(T::Boolean) }
def matches?(foo); end
```

Without all the Sorbet stuff in the `sig` that's an empty method definition which would
just return `nil` everytime.

But! Sorbet is doing the right thing! It kind of has to, or else it's interfaces would
be hard to work with. But its good to confirm, and write down for next time I run into this!

I bug a bit and found some code to replace and a method and some to call the original
implementation, so I assume some combination of these is how Sorbet pulls off this trick.
Maybe I'll dig deeper and turn this into a full post in the future.
